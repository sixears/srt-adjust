{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs               #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE NumericUnderscores         #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UnicodeSyntax              #-}
{-# LANGUAGE ViewPatterns               #-}

module Duration
  ( Duration( NS, MS, US, SECS, MINS, HOURS, DAYS, DHMS_NS, HMS_MS )
  , asNanoseconds, fromNanos
  , asMicroseconds, microseconds, _us
  , asMilliseconds, milliseconds, _ms
  , asSeconds, seconds
  , asMinutes, minutes
  , asHours, hours
  , asDays, days

  , tests
  )
where

import Prelude  ( Bounded( maxBound, minBound ), Double, Enum, Float, Fractional
                , Integral( quotRem, toInteger )
                , Num( (+), (-), (*), abs, fromInteger, negate, signum )
                , Real( toRational )
                , (^), fromIntegral, realToFrac, round
                )

-- base --------------------------------

import Control.Applicative  ( pure, some )
import Control.Exception    ( ArithException( Overflow, Underflow ), throw )
import Control.Monad        ( Monad )
import Data.Bifunctor       ( first, second )
import Data.Bool            ( otherwise )
import Data.Eq              ( Eq )
import Data.Foldable        ( sum )
import Data.Function        ( ($), id )
import Data.Int             ( Int64 )
import Data.List            ( dropWhileEnd, reverse )
import Data.Maybe           ( Maybe( Just ) )
import Data.Ord             ( Ord, (<), (>) )
import Data.Proxy           ( Proxy( Proxy ) )
import Data.Ratio           ( Rational, (%) )
import Data.String          ( String )
import Data.Tuple           ( fst, snd )
import System.Exit          ( ExitCode )
import System.IO            ( IO )
import Text.Read            ( read )
import Text.Show            ( Show )

-- base-unicode-symbols ----------------

import Data.Eq.Unicode        ( (‚â°) )
import Data.Function.Unicode  ( (‚àò) )
import Prelude.Unicode        ( ‚Ñö, ‚Ñ§ )

-- boundedn ----------------------------

import BoundedN  ( ùïé, pattern ùïé, (‚®π), (‚®¥), (‚®µ), (‚´Ω), divModulo )

-- data-textual ------------------------

import Data.Textual             ( Printable( print ), Textual( textual )
                                , fromString, toText )
import Data.Textual.Fractional  ( Optional( Required )
                                , Sign( NonNegative )
                                , decExpSign, fraction', fractional, fractional'
                                , optSign, optSlash
                                )
import Data.Textual.Integral    ( Decimal( Decimal )
                                , bounded', nnUpTo, nonNegative )

-- lens --------------------------------

import Control.Lens.Getter  ( view )
import Control.Lens.Iso     ( Iso', iso )
import Control.Lens.Lens    ( Lens', lens )

-- more-unicode ------------------------

import Data.MoreUnicode.Applicative  ( (‚äµ), (‚ã™), (‚ã´), (‚à§) )
import Data.MoreUnicode.Function     ( (‚Öã) )
import Data.MoreUnicode.Functor      ( (‚ä≥) )
import Data.MoreUnicode.Lens         ( (‚ä£), (‚´£), (‚ä¢) )
import Data.MoreUnicode.Monoid       ( —é )
import Data.MoreUnicode.Natural      ( ‚Ñï )
import Data.MoreUnicode.Tasty        ( (‚âü) )

-- non-empty-containers ----------------

import NonEmptyContainers.SeqNE  ( (‚ãó) )

-- number ------------------------------

import Number  ( NumSign( MINUS, PLUS )
               , absT, __fromI, fromNumSign, toNum, toNumI )

-- parser-plus -------------------------

import ParserPlus  ( tries )

-- parsers -----------------------------

import qualified Text.Parser.Combinators

import Text.Parser.Char         ( CharParsing, char, digit, string )
import Text.Parser.Combinators  ( count, try )

-- QuickCheck --------------------------

import Test.QuickCheck.Arbitrary  ( Arbitrary )

-- tasty -------------------------------

import Test.Tasty  ( TestTree, testGroup )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( testCase )

-- tasty-plus --------------------------

import TastyPlus  ( propInvertibleText, runTestsP, runTestsReplay, runTestTree )

-- tasty-quickcheck --------------------

import Test.Tasty.QuickCheck  ( testProperty )

-- text --------------------------------

import Data.Text  ( pack )

-- text-printer ------------------------

import qualified  Text.Printer  as  P

-- tfmt --------------------------------

import Text.Fmt  ( fmt )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

(√∑) ‚à∑ ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí Rational
(√∑) = (%)

--------------------------------------------------------------------------------

-- TODO
-- Create & use bounded Rationals for Œºs/ms/s/h/d ?
-- use units/unit-defs package?  Will that allow for bounded things?
-- Bounded Duration; use in SRTTimeStamp
-- Negative Durations

-- maxBound @Int64 = 9223372036854775807ns
--                 = (9223372036s,854775807ns)
--                 = (153722867m,16s,854775807ns)
--                 = (2562047h,47m,16s,854775807ns)
--                 = (106751d,23h,47m,16s,854775807ns)
--                 ‚âÉ 292y
newtype Duration = Duration { unDuration ‚à∑ Int64 }
  deriving (Arbitrary, Bounded, Enum, Eq, Ord, Show)

-- | as a bounded type, with sign
durBounded ‚à∑ Duration ‚Üí (NumSign,ùïé 9223372036854775807)
durBounded = second __fromI ‚àò absT ‚àò unDuration

instance Printable Duration where
  print d =
    let HMS_NS g h m s ns = d
     in let sgn = if g ‚â° MINUS then "-" else ""
            suffix = if ns ‚â° ùïé 0
                     then ""
                     else let drop0s = dropWhileEnd (‚â° '0')
                           in pack $ '.' : drop0s ([fmt|%09n|] $ ns)
         in if toNumI h > 0
            then P.text $ [fmt|%s%nh%02nm%02n%ts|] sgn h m s suffix
            else if m > ùïé 0
                 then P.text $ [fmt|%s%nm%02n%ts|] sgn m s suffix
                 else P.text $ [fmt|%s%n%ts|] sgn s suffix

instance Textual Duration where
  textual = let nnfraction ‚à∑ (Monad Œ∑, CharParsing Œ∑, Fractional Œ±) ‚áí Œ∑ Œ±
                nnfraction = fraction' (pure NonNegative) Decimal optSlash

                nnfractional ‚à∑ (Monad Œ∑, CharParsing Œ∑, Fractional Œ±) ‚áí Œ∑ Œ±
                nnfractional = fractional' (pure NonNegative) Decimal Required
                                           (char '.' ‚ã´ pure ()) decExpSign

                frac ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí
                       (‚Ñö ‚Üí Duration) ‚Üí String ‚Üí [Œ∑ Duration]
                frac x y = [ x ‚ä≥ nnfraction ‚ã™ string y
                           , x ‚ä≥ nnfractional ‚ã™ string y ]

                parseNS ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parseNS = Duration ‚ä≥ bounded' optSign Decimal ‚ã™ string "ns"

                optmin ‚à∑ (CharParsing Œ∑, Num Œ±) ‚áí Œ∑ Œ±
                optmin = Text.Parser.Combinators.option 1 (char '-' ‚ã´ pure (-1))

                -- parse 0h0m0s0ms0us0ns, or any combination of those, summing
                -- up the pieces
                parsehms ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parsehms = (*) ‚ä≥ optmin
                               ‚äµ (sum ‚ä≥ some (tries $ —é [ frac US    "us"
                                                        , frac MS    "ms"
                                                        , frac SECS  "s"
                                                        , frac MINS  "m"
                                                        , frac HOURS "h"
                                                        ]
                                                      ‚ãó parseNS
                                             )
                           )

                -- parse "00:00","00:00,123","00:00:00.234987",etc.

                -- parse n denary digits and multiply by m
                parseDenary n m = ((*m) ‚àò read) ‚ä≥ (count n digit)
                -- parse up to n denary digits and multiply by 10 for each
                -- digit missing
                parseDenaries n =
                  tries $ [ parseDenary i (10^(n-i)) | i ‚Üê reverse [2..n] ]
                        ‚ãó parseDenary 1 (10^(n-1))

                -- parse seconds with up to 3 ms digits after a ',' (srt-style)
                parseMS ‚à∑ (CharParsing Œ∑, Monad Œ∑) ‚áí Œ∑ Duration
                parseMS = (\ s ms ‚Üí (SECS (s√∑1) + MS (ms√∑1))) ‚ä≥
                          nnUpTo Decimal 2 ‚äµ (char ',' ‚ã´ parseDenaries 3)

                -- parse a seconds value, which may either be regular decimal,
                -- or up-to-3-digits-after-a-comma style (srt-style).
                parseSecs ‚à∑ (CharParsing Œ∑, Monad Œ∑) ‚áí Œ∑ Duration
                parseSecs = try parseMS ‚à§ SECS ‚ä≥ fractional

                -- parse h:m:s format, allowing for decimal or comma subseconds
                parseHMSColons ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parseHMSColons = (\ g h m s ‚Üí g* (HOURS (h√∑1) + MINS (m√∑1) + s))
                               ‚ä≥ optmin
                               ‚äµ nonNegative Decimal ‚ã™ char ':'
                               ‚äµ nnUpTo Decimal 2 ‚ã™ char ':' ‚äµ parseSecs

                -- parse m:s format, allowing for decimal or comma subseconds
                parseMSColons ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parseMSColons = (\ g m s ‚Üí g * (MINS (m√∑1) + s))
                              ‚ä≥ optmin
                              ‚äµ (nonNegative Decimal ‚ã™ char ':') ‚äµ parseSecs

             in tries $ [parseHMSColons, parseMSColons] ‚ãó parsehms

textualTests ‚à∑ TestTree
textualTests =
  let a ‚â£ b = testCase b $ Just a ‚âü fromString b
   in testGroup "Textual"
                [ testCase "print 100ms"    $ "0.1s"     ‚âü toText (MS 100)
                , testCase "print 1s"       $ "1s"       ‚âü toText (SECS 1)
                , testCase "print 1m07s"    $ "1m07s"    ‚âü toText (SECS 67)
                , testCase "print 1h00m05s" $ "1h00m05s" ‚âü toText (SECS 3605)

                , NS               1_234  ‚â£ "1234ns"
                , Duration     1_234_000  ‚â£ "1234us"
                , MS               1_234  ‚â£ "1234ms"
                , SECS             1_234  ‚â£ "1234s"
                , MS              12_340  ‚â£ "12.34s"
                , Duration   352_941_176  ‚â£ "12/34s"
                , MS              12_034  ‚â£ "12s34ms"
                , MS              61_001  ‚â£ "1m1s1ms"

                , NS               (-1_234)  ‚â£ "-1234ns"
                , Duration     (-1_234_000)  ‚â£ "-1234us"
                , MS               (-1_234)  ‚â£ "-1234ms"
                , SECS             (-1_234)  ‚â£ "-1234s"
                , MS              (-12_340)  ‚â£ "-12.34s"
                , Duration   (-352_941_176)  ‚â£ "-12/34s"
                , MS              (-12_034)  ‚â£ "-12s34ms"
                , MS              (-61_001)  ‚â£ "-1m1s1ms"

                , SECS             1_234  ‚â£ "20:34"
                , MS           1_234_500  ‚â£ "20:34,5"
                , MS           1_234_560  ‚â£ "20:34,56"
                , MS           1_234_567  ‚â£ "20:34,567"
                , MS           1_234_560  ‚â£ "20:34.56"
                , US       1_234_567_800  ‚â£ "20:34.5678"
                , SECS             4_834  ‚â£ "1:20:34"
                , MS           4_834_560  ‚â£ "1:20:34,56"
                , US       4_834_567_900  ‚â£ "1:20:34.5679"

                , SECS             (-1_234)  ‚â£ "-20:34"
                , MS           (-1_234_500)  ‚â£ "-20:34,5"
                , MS           (-1_234_560)  ‚â£ "-20:34,56"
                , MS           (-1_234_567)  ‚â£ "-20:34,567"
                , MS           (-1_234_560)  ‚â£ "-20:34.56"
                , US       (-1_234_567_800)  ‚â£ "-20:34.5678"
                , SECS             (-4_834)  ‚â£ "-1:20:34"
                , MS           (-4_834_560)  ‚â£ "-1:20:34,56"
                , US       (-4_834_567_900)  ‚â£ "-1:20:34.5679"

                , testProperty "invertibleText" (propInvertibleText @Duration)
                ]

{- | Create a duration from Nanoseconds (with bounds checking). -}
fromNanos ‚à∑ Integral Œ± ‚áí Œ± ‚Üí Duration
fromNanos n@(toInteger ‚Üí n')
               | n' < toInteger (minBound @Duration) = throw Underflow
               | n' > toInteger (maxBound @Duration) = throw Overflow
               | otherwise                           = Duration (fromIntegral n)

{- | View a duration as nanoseconds. -}
asNanoseconds ‚à∑ Integral Œ± ‚áí Iso' Duration Œ±
asNanoseconds = iso (\ (Duration n) ‚Üí fromIntegral n) fromNanos

pattern NS ‚à∑ Int64 ‚Üí Duration
pattern NS n ‚Üê Duration n
        where NS n = Duration n
{-# COMPLETE NS #-}

nsTests ‚à∑ TestTree
nsTests =
  let ns3 = Duration 3
   in testGroup "ns"
                [ testCase "3¬Ωms" $
                    (3_499_999‚à∑‚Ñ§) ‚âü Duration 3_499_999 ‚ä£ asNanoseconds
                , testCase "-‚Öîs" $
                    Duration (-666_667) ‚âü ((-666_667‚à∑‚Ñ§) ‚´£ asNanoseconds)
                , testCase "1.9...s" $
                      Duration 1_999_999_999
                    ‚âü (1_999_999_999‚à∑‚Ñ§) ‚´£ asNanoseconds
                , testCase "3ns" $ 3 ‚âü (\ (NS n) ‚Üí n) ns3
                , testCase "2ns" $ ns3 ‚âü NS 3
                ]

--------------------

{- | View a duration as microseconds. -}
asMicroseconds ‚à∑ Iso' Duration ‚Ñö
asMicroseconds = iso ((√∑ 1_000) ‚àò fromInteger ‚àò view asNanoseconds)
                     (Duration ‚àò round ‚àò (* 1_000))

{- | (De)Construct a Duration from a number of microseconds. -}
pattern US ‚à∑ ‚Ñö ‚Üí Duration
pattern US n ‚Üê (view asMicroseconds ‚Üí n)
        where US n = n ‚´£ asMicroseconds
{-# COMPLETE US #-}

{- | View/Set the microseconds 'part' of a Duration; getting will get the number
     of whole microseconds (rounded towards zero) ignoring milliseconds and
     sub-microseconds: setting will update the number of microseconds, leaving
     milliseconds and nanoseconds alone.
 -}
microseconds ‚à∑ Lens' Duration (ùïé 1000)
microseconds = _Œºs

{- | Alias for `microseconds`. -}
_Œºs ‚à∑ Lens' Duration (ùïé 1000)
_Œºs = _us

{- | Split a duration into milliseconds, microseconds, & nanoseconds. -}
msŒºsns ‚à∑ Duration ‚Üí (NumSign,ùïé 9_223_372_036_855,ùïé 1000, ùïé 1000)
msŒºsns d = let (g ,n)  = durBounded d
               (Œº ,ns) = n ‚´Ω Proxy @1000
               (ms,Œºs) = Œº ‚´Ω Proxy @1000
            in (g,ms,Œºs,ns)

{- | Form a duration from milliseconds, microseconds, & nanoseconds. -}
msŒºsns' ‚à∑ NumSign ‚Üí ùïé 9_223_372_036_855 ‚Üí ùïé 1000 ‚Üí  ùïé 1000 ‚Üí Duration
msŒºsns' g ms Œºs ns =
  Duration $ fromNumSign g * toNum(ns ‚®π Proxy @1000 ‚®¥ (Œºs ‚®π (Proxy @1000 ‚®¥ ms)))

{- | Alias for `microseconds`. -}
_us ‚à∑ Lens' Duration (ùïé 1000)
_us = lens (\ d ‚Üí let (_,ns) = durBounded d
                      (Œºs,_) = ns ‚´Ω Proxy @1_000
                   in snd $ Œºs ‚´Ω Proxy @1_000
           )
           (\ d Œºs ‚Üí let (g,ms,_,ns) = msŒºsns d
                     in msŒºsns' g ms Œºs ns)

ŒºsTests ‚à∑ TestTree
ŒºsTests =
  let us3 = Duration 3_000
      f3  = 3 ‚à∑ ‚Ñö
      dur = Duration 456_789_123_456_789
   in testGroup "Œºs"
                [ testCase "3¬Ωms" $
                      (3499.999 ‚à∑ Float)
                    ‚âü realToFrac
                        ((Duration 3_499_999 ‚ä£ asMicroseconds) ‚à∑ ‚Ñö)
                , testCase "‚ÖîŒºs" $
                    Duration 667 ‚âü ((two√∑three) ‚´£ asMicroseconds)
                , testCase "2ms" $
                      Duration 2_000
                    ‚âü ((realToFrac (1.999999999 ‚à∑ Double) ‚à∑ ‚Ñö)
                         ‚´£ asMicroseconds)
                , testCase "3Œºs" $ f3 ‚âü (\ (US n) ‚Üí n) us3
                , testCase "2Œºs" $ us3 ‚âü US f3
                , testCase "_us (get)" $ ùïé 456 ‚âü dur ‚ä£ _us
                , testCase "_us (set)" $   Duration 456_789_123_654_789
                                         ‚âü dur ‚Öã _us ‚ä¢ ùïé 654
                ]

--------------------

{- | View a duration as milliseconds. -}
asMilliseconds ‚à∑ Iso' Duration ‚Ñö
asMilliseconds = iso ((√∑ 1_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                     (Duration ‚àò round ‚àò (* 1_000_000))

{- | (De)Construct a Duration from a number of milliseconds. -}
pattern MS ‚à∑ ‚Ñö ‚Üí Duration
pattern MS n ‚Üê (view asMilliseconds ‚Üí n)
        where MS n = n ‚´£ asMilliseconds
{-# COMPLETE MS #-}

{- | View/Set the milliseconds 'part' of a Duration; getting will get the number
     of whole milliseconds (rounded towards zero) ignoring seconds and
     sub-milliseconds: setting will update the number of milliseconds, leaving
     seconds and microseconds alone.
 -}
milliseconds ‚à∑ Lens' Duration (ùïé 1000)
milliseconds = _ms

{- | Split a duration into milliseconds, microseconds, & nanoseconds. -}
smsŒºs ‚à∑ Duration ‚Üí (NumSign,ùïé 9_223_372_037,ùïé 1000, ùïé 1_000_000)
smsŒºs d = let (g,n)  = durBounded d
              (m,Œºs) = n ‚´Ω Proxy @1_000_000
              (s,ms) = m ‚´Ω Proxy @1000
           in (g,s,ms,Œºs)

{- | Form a duration from seconds, milliseconds, & microseconds. -}
smsŒºs' ‚à∑ NumSign ‚Üí ùïé 9_223_372_037 ‚Üí ùïé 1000 ‚Üí  ùïé 1_000_000 ‚Üí Duration
smsŒºs' g s ms Œºs =
  Duration $ fromNumSign g * toNum (Œºs ‚®π Proxy @1_000_000
                                       ‚®¥ (ms ‚®π (Proxy @1000 ‚®¥ s)))

{- | Alias for `milliseconds`. -}
_ms ‚à∑ Lens' Duration (ùïé 1000)
_ms = lens (\ d ‚Üí let (_,ns) = durBounded d
                      (ms,_) = ns ‚´Ω Proxy @1_000_000
                   in snd $ ms ‚´Ω Proxy @1_000
           )
           (\ d ms ‚Üí let (g,s,_,Œºs) = smsŒºs d
                      in smsŒºs' g s ms Œºs)

msTests ‚à∑ TestTree
msTests =
  let ms3 = Duration 3_000_000
      f3  = 3 ‚à∑ ‚Ñö
      dur = Duration (-456_789_123_456_789)
   in testGroup "ms"
                [ testCase "3¬Ωms" $
                      (3.499999 ‚à∑ Float)
                    ‚âü realToFrac
                        ((Duration 3_499_999 ‚ä£ asMilliseconds) ‚à∑ ‚Ñö)
                , testCase "‚Öîms" $
                    Duration 666667 ‚âü ((two√∑three) ‚´£ asMilliseconds)
                , testCase "2ms" $
                        Duration 2_000_000
                      ‚âü ((realToFrac (1.999999999 ‚à∑ Double) ‚à∑ ‚Ñö)
                           ‚´£ asMilliseconds)
                , testCase "3ms" $ f3 ‚âü (\ (MS n) ‚Üí n) ms3
                , testCase "3ms" $ ms3 ‚âü MS f3
                , testCase "_ms (get)" $ ùïé 123 ‚âü dur ‚ä£ _ms
                , testCase "_ms (set)" $   Duration (-456_789_321_456_789)
                                         ‚âü dur ‚Öã _ms ‚ä¢ ùïé 321
                ]

--------------------

{- | (De)Construct a Duration from Hours, Minutes, Seconds & Nanoseconds. -}

hms_ns ‚à∑ Duration ‚Üí (NumSign,ùïé 2562048,ùïé 60,ùïé 60,ùïé 1_000_000_000)
hms_ns (Duration n) = let (g,n')  = absT n
                          (s,ns)  = divModulo n'
                          (m,ss)  = divModulo s
                          (hh,mm) = first __fromI (divModulo m)
                       in (g,hh,mm,ss,ns)

----------

hms_ns' ‚à∑ NumSign ‚Üí ùïé 2562048 ‚Üí ùïé 60 ‚Üí ùïé 60 ‚Üí ùïé 1_000_000_000 ‚Üí Duration
hms_ns' sgn hh mm ss ns =
  let billion = Proxy @1_000_000_000
      n ‚à∑ ‚Ñï
      n = toNum $ ns ‚®π billion ‚®¥ (ss ‚®π (Proxy @60 ‚®¥ (mm ‚®π (Proxy @60 ‚®¥ hh))))
   in if n > fromIntegral (maxBound @Int64)
      then throw Overflow
      else Duration $ fromNumSign sgn * fromIntegral n

----------

pattern HMS_NS ‚à∑ NumSign ‚Üí ùïé 2562048 ‚Üí ùïé 60 ‚Üí ùïé 60 ‚Üí ùïé 1_000_000_000
                         ‚Üí Duration
pattern HMS_NS sgn hh mm ss ns ‚Üê (hms_ns ‚Üí (sgn,hh,mm,ss,ns))
        where HMS_NS = hms_ns'
{-# COMPLETE HMS_NS #-}

----------

hms_nsTests ‚à∑ TestTree
hms_nsTests =
  let dur = Duration (-3_723_000_000_004)
      HMS_NS g hh mm ss ns = dur
   in testGroup "HMS_NS"
                [ testCase "‚Üí HMS_NS" $ dur ‚âü HMS_NS MINUS (ùïé 1)(ùïé 2)(ùïé 3)(ùïé 4)
                , testCase "g"  $ MINUS ‚âü g
                , testCase "hh" $ ùïé 1   ‚âü hh
                , testCase "mm" $ ùïé 2   ‚âü mm
                , testCase "ss" $ ùïé 3   ‚âü ss
                , testCase "ns" $ ùïé 4   ‚âü ns
                ]

--------------------

{- | (De)Construct a Duration from Days, Hours, Minutes, Seconds &
     Nanoseconds. -}

dhms_ns ‚à∑ Duration ‚Üí (NumSign,ùïé 106752,ùïé 24,ùïé 60,ùïé 60,ùïé 1_000_000_000)
dhms_ns u = let (g,ns) = durBounded u
                (s,nn) = ns ‚´Ω Proxy @1_000_000_000
                (m,ss) = s  ‚´Ω Proxy @60
                (h,mm) = m  ‚´Ω Proxy @60
                (d,hh) = h  ‚´Ω Proxy @24
             in (g,d,hh,mm,ss,nn)

----------

dhms_ns' ‚à∑ NumSign ‚Üí ùïé 106752 ‚Üí ùïé 24 ‚Üí ùïé 60 ‚Üí ùïé 60 ‚Üí ùïé 1_000_000_000 ‚Üí Duration
dhms_ns' sgn dd hh mm ss ns =
  let billion = Proxy @1_000_000_000
      s ‚à∑ ùïé 9223462860
      s = ss ‚®π (Proxy @60 ‚®¥ (mm ‚®π (Proxy @60 ‚®¥ (hh ‚®π (Proxy @24 ‚®¥ dd)))))
      n ‚à∑ ‚Ñï
      n = toNum $ ns ‚®π billion ‚®¥ s
   in if n > fromIntegral (maxBound @Int64)
      then throw Overflow
      else Duration $ fromNumSign sgn * fromIntegral n

----------

pattern DHMS_NS ‚à∑ NumSign ‚Üí ùïé 106752 ‚Üí ùïé 24 ‚Üí ùïé 60 ‚Üí ùïé 60 ‚Üí ùïé 1_000_000_000
                ‚Üí Duration
pattern DHMS_NS g dd hh mm ss ns ‚Üê (dhms_ns ‚Üí (g,dd,hh,mm,ss,ns))
        where DHMS_NS = dhms_ns'
{-# COMPLETE DHMS_NS #-}

----------

dhms_nsTests ‚à∑ TestTree
dhms_nsTests =
  let dur = Duration 93_784_000_000_005
      DHMS_NS g dd hh mm ss ns = dur
   in testGroup "DHMS_NS"
                [ testCase "‚Üí DHMS_NS" $ dur ‚âü DHMS_NS PLUS (ùïé 1) (ùïé 2) (ùïé 3)
                                                                   (ùïé 4) (ùïé 5)
                , testCase "g"  $ PLUS ‚âü g
                , testCase "dd" $ ùïé 1 ‚âü dd
                , testCase "hh" $ ùïé 2 ‚âü hh
                , testCase "mm" $ ùïé 3 ‚âü mm
                , testCase "ss" $ ùïé 4 ‚âü ss
                , testCase "ns" $ ùïé 5 ‚âü ns
                ]

--------------------

{- | (De)Construct a Duration from Hours, Minutes, Seconds & Milliseconds.
     Deconstruction will round sub-milliseconds to the nearest millisecond
     value.
-}

hms_ms ‚à∑ Duration ‚Üí (NumSign,ùïé 2562048,ùïé 60,ùïé 60,ùïé 1000)
hms_ms d = let HMS_NS g hh mm ss ns = d
            in (g,hh,mm,ss, (fst ‚àò (‚´Ω Proxy @1_000_000)) ns)

----------

pattern HMS_MS ‚à∑ NumSign ‚Üí ùïé 2562048 ‚Üí ùïé 60 ‚Üí ùïé 60 ‚Üí ùïé 1000 ‚Üí Duration
pattern HMS_MS g hh mm ss ms ‚Üê (hms_ms ‚Üí (g,hh,mm,ss,ms))
        where HMS_MS g hh mm ss ms = HMS_NS g hh mm ss (ms ‚®µ Proxy @1_000_000)
{-# COMPLETE HMS_NS #-}

hms_msTests ‚à∑ TestTree
hms_msTests =
  let dur  = Duration 4_834_567_567_123
      dur' = Duration (-4_834_568_000_000)
      HMS_MS g hh mm ss ms = dur
   in testGroup "HMS_MS"
                [ testCase "hms_ms"   $  (PLUS,ùïé 1,ùïé 20,ùïé 34,ùïé 567) ‚âü hms_ms dur
                , testCase "‚Üí HMS_MS" $  dur' ‚âü HMS_MS MINUS (ùïé 1) (ùïé 20) (ùïé 34)
                                                             (ùïé 568)
                , testCase "g"        $ PLUS  ‚âü g
                , testCase "hh"       $ ùïé   1 ‚âü hh
                , testCase "mm"       $ ùïé  20 ‚âü mm
                , testCase "ss"       $ ùïé  34 ‚âü ss
                , testCase "ms"       $ ùïé 567 ‚âü ms
                ]

----------------------------------------

{- | View a duration as seconds. -}
asSeconds ‚à∑ Iso' Duration ‚Ñö
asSeconds = iso ((√∑ 1_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                (Duration ‚àò round ‚àò (*1_000_000_000))

{- | (De)Construct a Duration from a number of seconds. -}
pattern SECS ‚à∑ ‚Ñö ‚Üí Duration
pattern SECS n ‚Üê (view asSeconds ‚Üí n)
        where SECS n = n ‚´£ asSeconds
{-# COMPLETE SECS #-}

{- | A lens onto the seconds 'part' of the duration. -}
seconds ‚à∑ Lens' Duration (ùïé 60)
seconds = lens (\ d   ‚Üí let HMS_NS _ _ _ s _  = d in s)
               (\ d s ‚Üí let HMS_NS g h m _ ns = d in HMS_NS g h m s ns)

secsTests ‚à∑ TestTree
secsTests =
  let s3 = Duration 3_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration 3_723_123_456_789
      dur' = Duration 3_729_123_456_789
   in testGroup "seconds"
                [ testCase "3s" $ ùïé 3 ‚âü dur ‚ä£ seconds
                , testCase "s ‚Üí 9" $ dur' ‚âü dur ‚Öã seconds ‚ä¢ ùïé 9
                , testCase "3¬Ωs" $
                      (3_499_999_999√∑1_000_000_000)
                    ‚âü Duration 3_499_999_999 ‚ä£ asSeconds
                , testCase "‚Öîs" $
                    Duration 666_666_667 ‚âü ((two√∑three) ‚´£ asSeconds)
                , testCase "2s" $
                    Duration 2_000_000_000 ‚âü (2 ‚´£ asSeconds)
                , testCase "3s" $ f3 ‚âü (\ (SECS n) ‚Üí n) s3
                , testCase "3s" $ s3 ‚âü SECS f3
                ]

--------------------

{- | View a duration as minutes. -}
asMinutes ‚à∑ Iso' Duration ‚Ñö
asMinutes = iso ((√∑ 60_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 60_000_000_000))

{- | (De)Construct a Duration from a number of minutes. -}
pattern MINS ‚à∑ ‚Ñö ‚Üí Duration
pattern MINS n ‚Üê (view asMinutes ‚Üí n)
        where MINS n = n ‚´£ asMinutes
{-# COMPLETE MINS #-}

{- | A lens onto the minutes 'part' of the duration. -}
minutes ‚à∑ Lens' Duration (ùïé 60)
minutes = lens (\ d   ‚Üí let HMS_NS _ _ m _ _  = d in m)
               (\ d m ‚Üí let HMS_NS g h _ s ns = d in HMS_NS g h m s ns)

minsTests ‚à∑ TestTree
minsTests =
  let s3 = Duration 180_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration 3_723_123_456_789
      dur' = Duration 3_783_123_456_789
   in testGroup "minutes"
                [ testCase "2mins"    $ ùïé 2 ‚âü dur ‚ä£ minutes
                , testCase "mins ‚Üí 3" $ dur' ‚âü dur ‚Öã minutes ‚ä¢ ùïé 3
                , testCase "3¬Ωmins" $
                      (3_499_999_999√∑60_000_000_000)
                    ‚âü Duration 3_499_999_999 ‚ä£ asMinutes
                , testCase "‚Öîus" $
                    Duration 40_000_000_000 ‚âü ((two√∑three) ‚´£ asMinutes)
                , testCase "2mins" $
                    Duration 120_000_000_000 ‚âü (2 ‚´£ asMinutes)
                , testCase "3mins" $ f3 ‚âü (\ (MINS n) ‚Üí n) s3
                , testCase "3mins" $ s3 ‚âü MINS f3
                ]

----------------------------------------

{- | View a duration as hours. -}
asHours ‚à∑ Iso' Duration ‚Ñö
asHours = iso ((√∑ 3_600_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 3_600_000_000_000))

{- | (De)Construct a Duration from a number of hours. -}
pattern HOURS ‚à∑ ‚Ñö ‚Üí Duration
pattern HOURS n ‚Üê (view asHours ‚Üí n)
        where HOURS n = n ‚´£ asHours
{-# COMPLETE HOURS #-}

{- | A lens onto the hours 'part' of the duration. -}
hours ‚à∑ Lens' Duration (ùïé 2562048)
hours = lens (\ d   ‚Üí let HMS_NS _ h _ _ _  = d in h)
             (\ d h ‚Üí let HMS_NS g _ m s ns = d in HMS_NS g h m s ns)

hoursTests ‚à∑ TestTree
hoursTests =
  let s3 = Duration 10_800_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration  3_723_123_456_789
      dur' = Duration 10_923_123_456_789
   in testGroup "hours"
                [ testCase "1hour"     $ ùïé 1 ‚âü dur ‚ä£ hours
                , testCase "hours ‚Üí 3" $ dur' ‚âü dur ‚Öã hours ‚ä¢ ùïé 3
                , testCase "3¬Ωhours" $
                      (3_499_999_999√∑3_600_000_000_000)
                    ‚âü Duration 3_499_999_999 ‚ä£ asHours
                , testCase "‚Öîus" $
                    Duration 2_400_000_000_000 ‚âü ((two√∑three) ‚´£ asHours)
                , testCase "2hours" $
                    Duration 7_200_000_000_000 ‚âü (2 ‚´£ asHours)
                , testCase "3hours" $ f3 ‚âü (\ (HOURS n) ‚Üí n) s3
                , testCase "3hours" $ s3 ‚âü HOURS f3
                ]

----------------------------------------

{- | View a duration as days. -}
asDays ‚à∑ Iso' Duration ‚Ñö
asDays = iso ((√∑ 86_400_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 86_400_000_000_000))

{- | (De)Construct a Duration from a number of days. -}
pattern DAYS ‚à∑ ‚Ñö ‚Üí Duration
pattern DAYS n ‚Üê (view asDays ‚Üí n)
        where DAYS n = n ‚´£ asDays
{-# COMPLETE DAYS #-}

{- | A lens onto the days 'part' of the duration. -}
days ‚à∑ Lens' Duration (ùïé 106752)
days = lens (\ du ‚Üí let DHMS_NS _ da _ _ _ _ = du in da)
             (\ du da ‚Üí let DHMS_NS g _ h m s ns = du in DHMS_NS g da h m s ns)

daysTests ‚à∑ TestTree
daysTests =
  let s3 = Duration 259_200_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration 89_532_723_123_456_789
      dur' = Duration 281_523_123_456_789
   in testGroup "days"
                [ testCase "1,036days" $ ùïé 1_036 ‚âü dur ‚ä£ days
                , testCase "days ‚Üí 3" $ dur' ‚âü dur ‚Öã days ‚ä¢ ùïé 3
                , testCase "3¬Ωdays" $
                      (7√∑2) ‚âü Duration 302_400_000_000_000 ‚ä£ asDays
                , testCase "‚Öîus" $
                    Duration 57_600_000_000_000 ‚âü ((two√∑three) ‚´£ asDays)
                , testCase "2days" $
                    Duration 172_800_000_000_000 ‚âü (2 ‚´£ asDays)
                , testCase "3days" $ f3 ‚âü (\ (DAYS n) ‚Üí n) s3
                , testCase "3days" $ s3 ‚âü DAYS f3
                ]

--------------------

instance Num Duration where
  (Duration a) + (Duration b) = fromInteger (toInteger (a + b))
  (Duration a) - (Duration b) = fromInteger (toInteger (a - b))
  (Duration a) * (Duration b) = fromInteger (toInteger (a * b))

  negate (Duration 0) = 0
  negate (Duration n) = Duration (negate n)

  fromInteger ‚à∑ ‚Ñ§ ‚Üí Duration
  fromInteger = (‚´£ asNanoseconds)

  abs = id

  signum (Duration ns) = Duration (signum ns)

instance Real Duration where
  toRational ‚à∑ Duration ‚Üí ‚Ñö
  toRational (Duration n) = toRational n

instance Integral Duration where
  quotRem (Duration a) (Duration b) = let (q,r) = a `quotRem` b
                                 in (Duration q,Duration r)
  toInteger ‚à∑ Duration ‚Üí ‚Ñ§
  toInteger (Duration n) = toInteger n

--------------------------------------------------------------------------------
--                                   tests                                    --
--------------------------------------------------------------------------------

-- testdata ------------------------------------------------

two ‚à∑ ‚Ñ§
two = 2

three ‚à∑ ‚Ñ§
three = 3

------------------------------------------------------------

tests ‚à∑ TestTree
tests =
  testGroup "Duration" [ textualTests, nsTests, ŒºsTests, dhms_nsTests
                       , hms_nsTests, hms_msTests, msTests, secsTests
                       , minsTests, hoursTests, daysTests
                       ]
----------------------------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ String ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ String ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
