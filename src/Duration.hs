{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs               #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE NumericUnderscores         #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UnicodeSyntax              #-}
{-# LANGUAGE ViewPatterns               #-}

module Duration
  ( Duration( HMS_MS, MS ), NumSign(..)
  , asMilliseconds, milliseconds, microseconds

  , tests
  )
where

import Prelude  ( Bounded( maxBound, minBound ), Double, Enum, Float, Fractional
                , Integral( quotRem, toInteger )
                , Num( (+), (-), (*), abs, fromInteger, negate, signum )
                , Real( toRational )
                , (^), div, divMod, fromIntegral, mod, realToFrac, round
                )

-- base --------------------------------

import Control.Applicative  ( pure, some )
import Control.Exception    ( ArithException( Overflow, Underflow ), throw )
import Control.Monad        ( Monad )
import Data.Bifunctor       ( bimap, second )
import Data.Bool            ( otherwise )
import Data.Eq              ( Eq )
import Data.Foldable        ( sum )
import Data.Function        ( ($), id )
import Data.Int             ( Int64 )
import Data.List            ( dropWhileEnd, reverse )
import Data.Maybe           ( Maybe( Just ) )
import Data.Ord             ( Ord, (<), (>) )
import Data.Ratio           ( Rational, (%) )
import Data.String          ( String )
import Data.Word            ( Word16, Word32, Word64 )
import System.Exit          ( ExitCode )
import System.IO            ( IO )
import Text.Read            ( read )
import Text.Show            ( Show )

-- base-unicode-symbols ----------------

import Data.Eq.Unicode        ( (‚â°) )
import Data.Function.Unicode  ( (‚àò) )
import Data.Ord.Unicode       ( (‚â•) )
import Prelude.Unicode        ( ‚Ñö, ‚Ñ§ )

-- boundedn ----------------------------

import BoundedN  ( ùïé, pattern ùïé )
import FromI     ( __fromI' )
import ToNum     ( toNum, toNumI )

-- data-textual ------------------------

import Data.Textual             ( Printable( print ), Textual( textual )
                                , fromString, toText )
import Data.Textual.Fractional  ( Optional( Required )
                                , Sign( NonNegative )
                                , decExpSign, fraction', fractional, fractional'
                                , optSign, optSlash
                                )
import Data.Textual.Integral    ( Decimal( Decimal )
                                , bounded', nnUpTo, nonNegative )

-- lens --------------------------------

import Control.Lens.Getter  ( view )
import Control.Lens.Iso     ( Iso', iso )
import Control.Lens.Lens    ( Lens', lens )

-- more-unicode ------------------------

import Data.MoreUnicode.Applicative  ( (‚äµ), (‚ã™), (‚ã´), (‚à§) )
import Data.MoreUnicode.Function     ( (‚Öã) )
import Data.MoreUnicode.Functor      ( (‚ä≥) )
import Data.MoreUnicode.Lens         ( (‚ä£), (‚´£), (‚ä¢) )
import Data.MoreUnicode.Monoid       ( —é )
import Data.MoreUnicode.Natural      ( ‚Ñï )
import Data.MoreUnicode.Tasty        ( (‚âü) )

-- non-empty-containers ----------------

import NonEmptyContainers.SeqNE  ( (‚ãó) )

-- parser-plus -------------------------

import ParserPlus  ( tries )

-- parsers -----------------------------

import qualified Text.Parser.Combinators

import Text.Parser.Char         ( CharParsing, char, digit, string )
import Text.Parser.Combinators  ( count, try )

-- QuickCheck --------------------------

import Test.QuickCheck.Arbitrary  ( Arbitrary )

-- tasty -------------------------------

import Test.Tasty  ( TestTree, testGroup )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( testCase )

-- tasty-plus --------------------------

import TastyPlus  ( propInvertibleText, runTestsP, runTestsReplay, runTestTree )

-- tasty-quickcheck --------------------

import Test.Tasty.QuickCheck  ( testProperty )

-- text --------------------------------

import Data.Text  ( pack )

-- text-printer ------------------------

import qualified  Text.Printer  as  P

-- tfmt --------------------------------

import Text.Fmt  ( fmt )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

(√∑) ‚à∑ ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí Rational
(√∑) = (%)

--------------------------------------------------------------------------------

{- | Much like `signum`, but using a strong type. -}
data NumSign = MINUS | NOUGHT | PLUS
  deriving (Eq,Show)

toNumSign ‚à∑ (Ord Œ±, Num Œ±) ‚áí Œ± ‚Üí NumSign
toNumSign a | a < 0     = MINUS
            | a > 0     = PLUS
            | otherwise = NOUGHT

fromNumSign ‚à∑ Num Œ± ‚áí NumSign ‚Üí Œ±
fromNumSign MINUS  = -1
fromNumSign PLUS   =  1
fromNumSign NOUGHT =  0

------------------------------------------------------------

type N60 = ùïé 60

------------------------------------------------------------

type N24 = ùïé 24

------------------------------------------------------------

type NE9 = ùïé 1_000_000_000

------------------------------------------------------------

{- | Bounded to max. number of hours in a `Duration` (2,562,047). -}
type N2562047 = ùïé 2562047

------------------------------------------------------------

{- | Bounded to max. number of days in a `Duration` (106,751). -}
type N106751 = ùïé 106751

------------------------------------------------------------

-- TODO
-- Create & use bounded Rationals for Œºs/ms/s/h/d ?
-- use units/unit-defs package?  Will that allow for bounded things?
-- Bounded Duration; use in SRTTimeStamp
-- Negative Durations
newtype Duration = Duration Int64 -- in nanoseconds, ‚â° 106,751 days ‚âÉ 292y
                                  -- ‚âÉ 2,562,047h
  deriving (Arbitrary, Bounded, Enum, Eq, Ord, Show)


instance Printable Duration where
  print d =
    let HMS_NS g h m s ns = d
     in let suffix = if ns ‚â° ùïé 0
                     then ""
                     else pack $ '.' : dropWhileEnd (‚â° '0')([fmt|%09d|] $ toNumI ns)
            sgn = if g ‚â° MINUS then "-" else ""
         in if toNumI h > 0
            then P.text $ [fmt|%s%dh%02dm%02d%ts|] sgn (toNumI h) (toNumI m) (toNumI s) suffix
            else if m > ùïé 0
                 then P.text $ [fmt|%s%dm%02d%ts|] sgn (toNumI m) (toNumI s) suffix
                 else P.text $ [fmt|%s%d%ts|] sgn (toNumI s) suffix

instance Textual Duration where
  textual = let nnfraction ‚à∑ (Monad Œ∑, CharParsing Œ∑, Fractional Œ±) ‚áí Œ∑ Œ±
                nnfraction = fraction' (pure NonNegative) Decimal optSlash

                nnfractional ‚à∑ (Monad Œ∑, CharParsing Œ∑, Fractional Œ±) ‚áí Œ∑ Œ±
                nnfractional = fractional' (pure NonNegative) Decimal Required
                                           (char '.' ‚ã´ pure ()) decExpSign

                frac ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí
                       (‚Ñö ‚Üí Duration) ‚Üí String ‚Üí [Œ∑ Duration]
                frac x y = [ x ‚ä≥ nnfraction ‚ã™ string y
                           , x ‚ä≥ nnfractional ‚ã™ string y ]

                parseNS ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parseNS = Duration ‚ä≥ bounded' optSign Decimal ‚ã™ string "ns"
                -- parse 0h0m0s0ms0us0ns, or any combination of those, summing
                -- up the pieces

                optmin ‚à∑ (CharParsing Œ∑, Num Œ±) ‚áí Œ∑ Œ±
                optmin = Text.Parser.Combinators.option 1 (char '-' ‚ã´ pure (-1))

                parsehms ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parsehms = (*) ‚ä≥ optmin
                               ‚äµ (sum ‚ä≥ some (tries $ —é [ frac US    "us"
                                                        , frac MS    "ms"
                                                        , frac SECS  "s"
                                                        , frac MINS  "m"
                                                        , frac HOURS "h"
                                                        ]
                                                      ‚ãó parseNS
                                             )
                           )
                -- parse "00:00","00:00,123","00:00:00.234987",etc.

                -- parse n denary digits and multiply by m
                parseDenary n m = ((*m) ‚àò read) ‚ä≥ (count n digit)
                -- parse up to n denary digits and multiply by 10 for each
                -- digit missing
                parseDenaries n =
                  tries $ [ parseDenary i (10^(n-i)) | i ‚Üê reverse [2..n] ]
                        ‚ãó parseDenary 1 (10^(n-1))

                -- parse seconds with up to 3 ms digits after a ',' (srt-style)
                parseMS ‚à∑ (CharParsing Œ∑, Monad Œ∑) ‚áí Œ∑ Duration
                parseMS = (\ s ms ‚Üí (SECS (s√∑1) + MS (ms√∑1))) ‚ä≥
                          nnUpTo Decimal 2 ‚äµ (char ',' ‚ã´ parseDenaries 3)

                -- parse a seconds value, which may either be regular decimal,
                -- or up-to-3-digits-after-a-comma style (srt-style).
                parseSecs ‚à∑ (CharParsing Œ∑, Monad Œ∑) ‚áí Œ∑ Duration
                parseSecs = try parseMS ‚à§ SECS ‚ä≥ fractional

                -- parse h:m:s format, allowing for decimal or comma subseconds
                parseHMSColons ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parseHMSColons = (\ g h m s ‚Üí g* (HOURS (h√∑1) + MINS (m√∑1) + s))
                               ‚ä≥ optmin
                               ‚äµ nonNegative Decimal ‚ã™ char ':'
                               ‚äµ nnUpTo Decimal 2 ‚ã™ char ':' ‚äµ parseSecs

                -- parse m:s format, allowing for decimal or comma subseconds
                parseMSColons ‚à∑ (Monad Œ∑, CharParsing Œ∑) ‚áí Œ∑ Duration
                parseMSColons = (\ g m s ‚Üí g * (MINS (m√∑1) + s))
                              ‚ä≥ optmin
                              ‚äµ (nonNegative Decimal ‚ã™ char ':') ‚äµ parseSecs

             in tries $ [parseHMSColons, parseMSColons] ‚ãó parsehms

textualTests ‚à∑ TestTree
textualTests =
  let a ‚â£ b = testCase b $ Just a ‚âü fromString b
   in testGroup "Textual"
                [ testCase "print 100ms"    $ "0.1s"     ‚âü toText (MS 100)
                , testCase "print 1s"       $ "1s"       ‚âü toText (SECS 1)
                , testCase "print 1m07s"    $ "1m07s"    ‚âü toText (SECS 67)
                , testCase "print 1h00m05s" $ "1h00m05s" ‚âü toText (SECS 3605)

                , NS               1_234  ‚â£ "1234ns"
                , Duration     1_234_000  ‚â£ "1234us"
                , MS               1_234  ‚â£ "1234ms"
                , SECS             1_234  ‚â£ "1234s"
                , MS              12_340  ‚â£ "12.34s"
                , Duration   352_941_176  ‚â£ "12/34s"
                , MS              12_034  ‚â£ "12s34ms"
                , MS              61_001  ‚â£ "1m1s1ms"

                , NS               (-1_234)  ‚â£ "-1234ns"
                , Duration     (-1_234_000)  ‚â£ "-1234us"
                , MS               (-1_234)  ‚â£ "-1234ms"
                , SECS             (-1_234)  ‚â£ "-1234s"
                , MS              (-12_340)  ‚â£ "-12.34s"
                , Duration   (-352_941_176)  ‚â£ "-12/34s"
                , MS              (-12_034)  ‚â£ "-12s34ms"
                , MS              (-61_001)  ‚â£ "-1m1s1ms"

                , SECS             1_234  ‚â£ "20:34"
                , MS           1_234_500  ‚â£ "20:34,5"
                , MS           1_234_560  ‚â£ "20:34,56"
                , MS           1_234_567  ‚â£ "20:34,567"
                , MS           1_234_560  ‚â£ "20:34.56"
                , US       1_234_567_800  ‚â£ "20:34.5678"
                , SECS             4_834  ‚â£ "1:20:34"
                , MS           4_834_560  ‚â£ "1:20:34,56"
                , US       4_834_567_900  ‚â£ "1:20:34.5679"

                , SECS             (-1_234)  ‚â£ "-20:34"
                , MS           (-1_234_500)  ‚â£ "-20:34,5"
                , MS           (-1_234_560)  ‚â£ "-20:34,56"
                , MS           (-1_234_567)  ‚â£ "-20:34,567"
                , MS           (-1_234_560)  ‚â£ "-20:34.56"
                , US       (-1_234_567_800)  ‚â£ "-20:34.5678"
                , SECS             (-4_834)  ‚â£ "-1:20:34"
                , MS           (-4_834_560)  ‚â£ "-1:20:34,56"
                , US       (-4_834_567_900)  ‚â£ "-1:20:34.5679"

                , testProperty "invertibleText" (propInvertibleText @Duration)
                ]

{- | Create a duration from Nanoseconds (with bounds checking). -}
fromNanos ‚à∑ Integral Œ± ‚áí Œ± ‚Üí Duration
fromNanos n@(toInteger ‚Üí n')
               | n' < toInteger (minBound @Duration) = throw Underflow
               | n' > toInteger (maxBound @Duration) = throw Overflow
               | otherwise                           = Duration (fromIntegral n)

{- | View a duration as nanoseconds. -}
asNanoseconds ‚à∑ Integral Œ± ‚áí Iso' Duration Œ±
asNanoseconds = iso (\ (Duration n) ‚Üí fromIntegral n) fromNanos

pattern NS ‚à∑ Int64 ‚Üí Duration
pattern NS n ‚Üê Duration n
        where NS n = Duration n

nsTests ‚à∑ TestTree
nsTests =
  let ns3 = Duration 3
   in testGroup "ns"
                [ testCase "3¬Ωms" $
                    (3_499_999‚à∑‚Ñ§) ‚âü Duration 3_499_999 ‚ä£ asNanoseconds
                , testCase "‚Öîs" $
                    Duration 666_667 ‚âü ((666_667‚à∑‚Ñ§) ‚´£ asNanoseconds)
                , testCase "1.9...s" $
                      Duration 1_999_999_999
                    ‚âü (1_999_999_999‚à∑‚Ñ§) ‚´£ asNanoseconds
                , testCase "3ns" $ 3 ‚âü (\ (NS n) ‚Üí n) ns3
                , testCase "2ns" $ ns3 ‚âü NS 3
                ]

--------------------

{- | View a duration as microseconds. -}
asMicroseconds ‚à∑ Iso' Duration ‚Ñö
asMicroseconds = iso ((√∑ 1_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 1_000))

{- | (De)Construct a Duration from a number of microseconds. -}
pattern US ‚à∑ ‚Ñö ‚Üí Duration
pattern US n ‚Üê (view asMicroseconds ‚Üí n)
        where US n = n ‚´£ asMicroseconds

{- | View/Set the microseconds 'part' of a Duration; getting will get the whole
     (rounded towards zero) number of microseconds: setting will update the
     number of microseconds, leaving milliseconds and nanoseconds alone.
 -}
microseconds ‚à∑ Lens' Duration Word16
microseconds = _Œºs

{- | Alias for `microseconds`. -}
_Œºs ‚à∑ Lens' Duration Word16
_Œºs = _us

{- | Alias for `microseconds`. -}
_us ‚à∑ Lens' Duration Word16
_us = lens (\ (Duration n) ‚Üí (fromIntegral $ (n `div` 1_000) `mod` 1_000 ))
           (\ (Duration n) u ‚Üí let n' = n `mod` 1_000
                                   u' = fromIntegral u
                                   m' = n `div` 1_000_000
                                in if u ‚â• 1_000
                                   then throw Overflow
                                   else Duration $ m'*1_000_000 + u'*1_000 + n')

ŒºsTests ‚à∑ TestTree
ŒºsTests =
  let us3 = Duration 3_000
      f3  = 3 ‚à∑ ‚Ñö
      dur = Duration 456_789_123_456_789
   in testGroup "Œºs"
                [ testCase "3¬Ωms" $
                      (3499.999 ‚à∑ Float)
                    ‚âü realToFrac
                        ((Duration 3_499_999 ‚ä£ asMicroseconds) ‚à∑ ‚Ñö)
                , testCase "‚ÖîŒºs" $
                    Duration 667 ‚âü ((two√∑three) ‚´£ asMicroseconds)
                , testCase "2ms" $
                      Duration 2_000
                    ‚âü ((realToFrac (1.999999999 ‚à∑ Double) ‚à∑ ‚Ñö)
                         ‚´£ asMicroseconds)
                , testCase "3Œºs" $ f3 ‚âü (\ (US n) ‚Üí n) us3
                , testCase "2Œºs" $ us3 ‚âü US f3
                , testCase "_us (get)" $ 456 ‚âü dur ‚ä£ _us
                , testCase "_us (set)" $   Duration 456_789_123_654_789
                                         ‚âü dur ‚Öã _us ‚ä¢ 654
                ]

--------------------

{- | View a duration as milliseconds. -}
asMilliseconds ‚à∑ Iso' Duration ‚Ñö
asMilliseconds = iso ((√∑ 1_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 1_000_000))

{- | (De)Construct a Duration from a number of milliseconds. -}
pattern MS ‚à∑ ‚Ñö ‚Üí Duration
pattern MS n ‚Üê (view asMilliseconds ‚Üí n)
        where MS n = n ‚´£ asMilliseconds

{- | View/Set the milliseconds 'part' of a Duration; getting will get the whole
     (rounded towards zero) number of milliseconds: setting will update the
     number of milliseconds, leaving seconds and microseconds alone.
 -}
milliseconds ‚à∑ Lens' Duration Word16
milliseconds = _ms

{- | Alias for `milliseconds`. -}
_ms ‚à∑ Lens' Duration Word16
_ms = lens (\ (Duration n) ‚Üí (fromIntegral $ (n `div` 1_000_000) `mod` 1_000 ))
           (\ (Duration n) m ‚Üí let u' = n `mod` 1_000_000
                                   m' = fromIntegral m
                                   s' = n `div` 1_000_000_000
                                in if m ‚â• 1_000
                                   then throw Overflow
                                   else Duration $ sum [ s'*1_000_000_000
                                                       , m'*1_000_000, u' ]
           )

msTests ‚à∑ TestTree
msTests =
  let ms3 = Duration 3_000_000
      f3  = 3 ‚à∑ ‚Ñö
      dur = Duration 456_789_123_456_789
   in testGroup "ms"
                [ testCase "3¬Ωms" $
                      (3.499999 ‚à∑ Float)
                    ‚âü realToFrac
                        ((Duration 3_499_999 ‚ä£ asMilliseconds) ‚à∑ ‚Ñö)
                , testCase "‚Öîms" $
                    Duration 666667 ‚âü ((two√∑three) ‚´£ asMilliseconds)
                , testCase "2ms" $
                        Duration 2_000_000
                      ‚âü ((realToFrac (1.999999999 ‚à∑ Double) ‚à∑ ‚Ñö)
                           ‚´£ asMilliseconds)
                , testCase "3ms" $ f3 ‚âü (\ (MS n) ‚Üí n) ms3
                , testCase "3ms" $ ms3 ‚âü MS f3
                , testCase "_ms (get)" $ 123 ‚âü dur ‚ä£ _ms
                , testCase "_ms (set)" $   Duration 456_789_321_456_789
                                         ‚âü dur ‚Öã _ms ‚ä¢ 321
                ]

--------------------

{- | (De)Construct a Duration from Hours, Minutes, Seconds & Nanoseconds. -}

hms_ns ‚à∑ Duration ‚Üí (NumSign,N2562047,N60,N60,NE9)
hms_ns (Duration n) = let fromi ‚à∑ (Integral Œπ, Integral Œ∫, Num Œ±, Num Œ≤) ‚áí
                                  (Œπ,Œ∫) ‚Üí (Œ±,Œ≤)
                          fromi (x,y) = (fromIntegral x, fromIntegral y)
                          (s‚à∑Word64,ns)  = second __fromI' $ fromi $ abs n `divMod` 1_000_000_000
                          (m‚à∑Word32,ss)  = second __fromI' $ fromi $ s `divMod` 60
                          (hh,mm)        = bimap __fromI' __fromI' $ fromi $ m `divMod` 60
                       in (toNumSign n,hh,mm,ss,ns)

hms_ns' ‚à∑ NumSign ‚Üí N2562047 ‚Üí N60 ‚Üí N60 ‚Üí NE9 ‚Üí Duration
hms_ns' sgn hh mm ss ns = let mm' ‚à∑ ‚Ñï
                              mm' = toNum mm
                              ss' ‚à∑ ‚Ñï
                              ss' = toNum ss
                              bill‚Ñï ‚à∑ ‚Ñï
                              bill‚Ñï = 1_000_000_000
                              ns' = toNum ns
                              n ‚à∑ ‚Ñï
                              n = fromIntegral $
                                    ns' + bill‚Ñï * (ss'+ 60*(mm'+60*(toNum hh)))
                           in if n > fromIntegral (maxBound @Word64)
                              then throw Overflow
                              else Duration $ fromNumSign sgn * fromIntegral n

pattern HMS_NS ‚à∑ NumSign ‚Üí N2562047 ‚Üí N60 ‚Üí N60 ‚Üí NE9 ‚Üí Duration
pattern HMS_NS sgn hh mm ss ns ‚Üê (hms_ns ‚Üí (sgn,hh,mm,ss,ns))
        where HMS_NS = hms_ns'


hms_nsTests ‚à∑ TestTree
hms_nsTests =
  let dur = Duration (-3_723_000_000_004)
      HMS_NS g hh mm ss ns = dur
   in testGroup "HMS_NS"
                [ testCase "‚Üí HMS_NS" $ dur ‚âü HMS_NS MINUS (ùïé 1) (ùïé 2) (ùïé 3) (ùïé 4)
                , testCase "g"  $ MINUS ‚âü g
                , testCase "hh" $ ùïé 1   ‚âü hh
                , testCase "mm" $ ùïé 2   ‚âü mm
                , testCase "ss" $ ùïé 3   ‚âü ss
                , testCase "ns" $ ùïé 4   ‚âü ns
                ]

--------------------

{- | (De)Construct a Duration from Days, Hours, Minutes, Seconds &
     Nanoseconds. -}

dhms_ns ‚à∑ Duration ‚Üí (N106751,N24,N60,N60,NE9)
dhms_ns (Duration n) = let fromi ‚à∑ (Integral Œπ, Integral Œ∫, Num Œ±, Num Œ≤) ‚áí
                                   (Œπ,Œ∫) ‚Üí (Œ±,Œ≤)
                           fromi (x,y) = (fromIntegral x, fromIntegral y)
                           (s‚à∑Word64,ns)  = second __fromI' $ fromi $ n `divMod` 1_000_000_000
                           (m‚à∑Word32,ss)  = second __fromI' $ fromi $ s `divMod` 60
                           (h‚à∑Word32,mm)  = second __fromI' $ fromi $ m `divMod` 60
                           (dd,hh)        = bimap __fromI' __fromI' $ fromi $ h `divMod` 24
                        in (dd,hh,mm,ss,ns)

pattern DHMS_NS ‚à∑ N106751 ‚Üí N24 ‚Üí N60 ‚Üí N60 ‚Üí NE9 ‚Üí Duration
pattern DHMS_NS dd hh mm ss ns ‚Üê (dhms_ns ‚Üí (dd,hh,mm,ss,ns))
        where DHMS_NS dd hh mm ss ns =
                let hh' ‚à∑ ‚Ñï
                    hh' = toNum hh
                    mm' ‚à∑ ‚Ñï
                    mm' = toNum mm
                    ss' ‚à∑ ‚Ñï
                    ss' = toNum ss
                    bill‚Ñï ‚à∑ ‚Ñï
                    bill‚Ñï = 1_000_000_000
                    ns' = toNum ns
                    n ‚à∑ ‚Ñï
                    n = fromIntegral $
                          ns' + bill‚Ñï * (ss'+ 60*(mm'+60*(hh'+24*toNum dd)))
                 in if n > fromIntegral (maxBound @Word64)
                    then throw Overflow
                    else Duration $ fromIntegral n

dhms_nsTests ‚à∑ TestTree
dhms_nsTests =
  let dur = Duration 93_784_000_000_005
      DHMS_NS dd hh mm ss ns = dur
   in testGroup "DHMS_NS"
                [ testCase "‚Üí DHMS_NS" $ dur ‚âü DHMS_NS (ùïé 1) (ùïé 2) (ùïé 3) (ùïé 4) (ùïé 5)
                , testCase "dd" $ ùïé 1 ‚âü dd
                , testCase "hh" $ ùïé 2 ‚âü hh
                , testCase "mm" $ ùïé 3 ‚âü mm
                , testCase "ss" $ ùïé 4 ‚âü ss
                , testCase "ns" $ ùïé 5 ‚âü ns
                ]

--------------------

{- | (De)Construct a Duration from Hours, Minutes, Seconds & Milliseconds.
     Deconstruction will round sub-milliseconds to the nearest millisecond
     value.
-}

hms_ms ‚à∑ Duration ‚Üí (NumSign,N2562047,N60,N60,ùïé 1000)
hms_ms d = let HMS_NS g hh mm ss ns = d
            in (g,hh,mm,ss,ùïé (round $ toNumI ns √∑ 1_000_000))

pattern HMS_MS ‚à∑ NumSign ‚Üí N2562047 ‚Üí N60 ‚Üí N60 ‚Üí ùïé 1000 ‚Üí Duration
pattern HMS_MS g hh mm ss ms ‚Üê (hms_ms ‚Üí (g,hh,mm,ss,ms))
        where HMS_MS g hh mm ss ms = HMS_NS g hh mm ss (__fromI' $ toNum ms * 1_000_000)

hms_msTests ‚à∑ TestTree
hms_msTests =
  let dur  = Duration 4_834_567_567_123
      dur' = Duration (-4_834_568_000_000)
      HMS_MS g hh mm ss ms = dur
   in testGroup "HMS_MS"
                [ testCase "hms_ms"   $  (PLUS,ùïé 1,ùïé 20,ùïé 34,ùïé 568) ‚âü hms_ms dur
                , testCase "‚Üí HMS_MS" $  dur' ‚âü HMS_MS MINUS (ùïé 1) (ùïé 20) (ùïé 34) (ùïé 568)
                , testCase "g"        $ PLUS  ‚âü g
                , testCase "hh"       $ ùïé   1 ‚âü hh
                , testCase "mm"       $ ùïé  20 ‚âü mm
                , testCase "ss"       $ ùïé  34 ‚âü ss
                , testCase "ms"       $ ùïé 568 ‚âü ms
                ]

----------------------------------------

{- | View a duration as seconds. -}
asSeconds ‚à∑ Iso' Duration ‚Ñö
asSeconds = iso ((√∑ 1_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                (Duration ‚àò round ‚àò (*1_000_000_000))

{- | (De)Construct a Duration from a number of seconds. -}
pattern SECS ‚à∑ ‚Ñö ‚Üí Duration
pattern SECS n ‚Üê (view asSeconds ‚Üí n)
        where SECS n = n ‚´£ asSeconds

{- | A lens onto the seconds 'part' of the duration. -}
seconds ‚à∑ Lens' Duration N60
seconds = lens (\ d   ‚Üí let HMS_NS _ _ _ s _  = d in s)
               (\ d s ‚Üí let HMS_NS g h m _ ns = d in HMS_NS g h m s ns)

secsTests ‚à∑ TestTree
secsTests =
  let s3 = Duration 3_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration 3_723_123_456_789
      dur' = Duration 3_729_123_456_789
   in testGroup "seconds"
                [ testCase "3s" $ ùïé 3 ‚âü dur ‚ä£ seconds
                , testCase "s ‚Üí 9" $ dur' ‚âü dur ‚Öã seconds ‚ä¢ ùïé 9
                , testCase "3¬Ωs" $
                      (3_499_999_999√∑1_000_000_000)
                    ‚âü Duration 3_499_999_999 ‚ä£ asSeconds
                , testCase "‚Öîs" $
                    Duration 666_666_667 ‚âü ((two√∑three) ‚´£ asSeconds)
                , testCase "2s" $
                    Duration 2_000_000_000 ‚âü (2 ‚´£ asSeconds)
                , testCase "3s" $ f3 ‚âü (\ (SECS n) ‚Üí n) s3
                , testCase "3s" $ s3 ‚âü SECS f3
                ]

--------------------

{- | View a duration as minutes. -}
asMinutes ‚à∑ Iso' Duration ‚Ñö
asMinutes = iso ((√∑ 60_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 60_000_000_000))

{- | (De)Construct a Duration from a number of minutes. -}
pattern MINS ‚à∑ ‚Ñö ‚Üí Duration
pattern MINS n ‚Üê (view asMinutes ‚Üí n)
        where MINS n = n ‚´£ asMinutes

{- | A lens onto the minutes 'part' of the duration. -}
minutes ‚à∑ Lens' Duration N60
minutes = lens (\ d   ‚Üí let HMS_NS _ _ m _ _  = d in m)
               (\ d m ‚Üí let HMS_NS g h _ s ns = d in HMS_NS g h m s ns)

minsTests ‚à∑ TestTree
minsTests =
  let s3 = Duration 180_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration 3_723_123_456_789
      dur' = Duration 3_783_123_456_789
   in testGroup "minutes"
                [ testCase "2mins"    $ ùïé 2 ‚âü dur ‚ä£ minutes
                , testCase "mins ‚Üí 3" $ dur' ‚âü dur ‚Öã minutes ‚ä¢ ùïé 3
                , testCase "3¬Ωmins" $
                      (3_499_999_999√∑60_000_000_000)
                    ‚âü Duration 3_499_999_999 ‚ä£ asMinutes
                , testCase "‚Öîus" $
                    Duration 40_000_000_000 ‚âü ((two√∑three) ‚´£ asMinutes)
                , testCase "2mins" $
                    Duration 120_000_000_000 ‚âü (2 ‚´£ asMinutes)
                , testCase "3mins" $ f3 ‚âü (\ (MINS n) ‚Üí n) s3
                , testCase "3mins" $ s3 ‚âü MINS f3
                ]

----------------------------------------

{- | View a duration as hours. -}
asHours ‚à∑ Iso' Duration ‚Ñö
asHours = iso ((√∑ 3_600_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 3_600_000_000_000))

{- | (De)Construct a Duration from a number of hours. -}
pattern HOURS ‚à∑ ‚Ñö ‚Üí Duration
pattern HOURS n ‚Üê (view asHours ‚Üí n)
        where HOURS n = n ‚´£ asHours

{- | A lens onto the hours 'part' of the duration. -}
hours ‚à∑ Lens' Duration N2562047
hours = lens (\ d   ‚Üí let HMS_NS _ h _ _ _  = d in h)
             (\ d h ‚Üí let HMS_NS g _ m s ns = d in HMS_NS g h m s ns)

hoursTests ‚à∑ TestTree
hoursTests =
  let s3 = Duration 10_800_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration  3_723_123_456_789
      dur' = Duration 10_923_123_456_789
   in testGroup "hours"
                [ testCase "1hour"     $ ùïé 1 ‚âü dur ‚ä£ hours
                , testCase "hours ‚Üí 3" $ dur' ‚âü dur ‚Öã hours ‚ä¢ ùïé 3
                , testCase "3¬Ωhours" $
                      (3_499_999_999√∑3_600_000_000_000)
                    ‚âü Duration 3_499_999_999 ‚ä£ asHours
                , testCase "‚Öîus" $
                    Duration 2_400_000_000_000 ‚âü ((two√∑three) ‚´£ asHours)
                , testCase "2hours" $
                    Duration 7_200_000_000_000 ‚âü (2 ‚´£ asHours)
                , testCase "3hours" $ f3 ‚âü (\ (HOURS n) ‚Üí n) s3
                , testCase "3hours" $ s3 ‚âü HOURS f3
                ]

----------------------------------------

{- | View a duration as days. -}
asDays ‚à∑ Iso' Duration ‚Ñö
asDays = iso ((√∑ 86_400_000_000_000) ‚àò fromInteger ‚àò view asNanoseconds)
                  (Duration ‚àò round ‚àò (* 86_400_000_000_000))

{- | (De)Construct a Duration from a number of days. -}
pattern DAYS ‚à∑ ‚Ñö ‚Üí Duration
pattern DAYS n ‚Üê (view asDays ‚Üí n)
        where DAYS n = n ‚´£ asDays

{- | A lens onto the days 'part' of the duration. -}
days ‚à∑ Lens' Duration N106751
days = lens (\ du ‚Üí let DHMS_NS da _ _ _ _ = du in da)
             (\ du da ‚Üí let DHMS_NS _ h m s ns = du in DHMS_NS da h m s ns)

daysTests ‚à∑ TestTree
daysTests =
  let s3 = Duration 259_200_000_000_000
      f3 = 3 ‚à∑ ‚Ñö
      dur  = Duration 89_532_723_123_456_789
      dur' = Duration 281_523_123_456_789
   in testGroup "days"
                [ testCase "1,036days" $ ùïé 1_036 ‚âü dur ‚ä£ days
                , testCase "days ‚Üí 3" $ dur' ‚âü dur ‚Öã days ‚ä¢ ùïé 3
                , testCase "3¬Ωdays" $
                      (7√∑2) ‚âü Duration 302_400_000_000_000 ‚ä£ asDays
                , testCase "‚Öîus" $
                    Duration 57_600_000_000_000 ‚âü ((two√∑three) ‚´£ asDays)
                , testCase "2days" $
                    Duration 172_800_000_000_000 ‚âü (2 ‚´£ asDays)
                , testCase "3days" $ f3 ‚âü (\ (DAYS n) ‚Üí n) s3
                , testCase "3days" $ s3 ‚âü DAYS f3
                ]

--------------------

instance Num Duration where
  (Duration a) + (Duration b) = fromInteger (toInteger (a + b))
  (Duration a) - (Duration b) = fromInteger (toInteger (a - b))
  (Duration a) * (Duration b) = fromInteger (toInteger (a * b))

  negate (Duration 0) = 0
  negate (Duration n) = Duration (negate n)

  fromInteger ‚à∑ ‚Ñ§ ‚Üí Duration
  fromInteger = (‚´£ asNanoseconds)

  abs = id

  signum (Duration ns) = Duration (signum ns)

instance Real Duration where
  toRational ‚à∑ Duration ‚Üí ‚Ñö
  toRational (Duration n) = toRational n

instance Integral Duration where
  quotRem (Duration a) (Duration b) = let (q,r) = a `quotRem` b
                                 in (Duration q,Duration r)
  toInteger ‚à∑ Duration ‚Üí ‚Ñ§
  toInteger (Duration n) = toInteger n

--------------------------------------------------------------------------------
--                                   tests                                    --
--------------------------------------------------------------------------------

-- testdata ------------------------------------------------

two ‚à∑ ‚Ñ§
two = 2

three ‚à∑ ‚Ñ§
three = 3

------------------------------------------------------------

tests ‚à∑ TestTree
tests =
  testGroup "Duration" [ textualTests, nsTests, ŒºsTests, dhms_nsTests
                       , hms_nsTests, hms_msTests, msTests, secsTests
                       , minsTests, hoursTests, daysTests
                       ]
----------------------------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ String ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ String ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
